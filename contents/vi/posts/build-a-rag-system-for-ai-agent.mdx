---
title: X√¢y d·ª±ng h·ªá th·ªëng RAG cho AI agent
date: 2025-03-30T06:30:00+07:00
published: true
tags:
- ai
- rag
- redisearch
categories:
- AI
description: |
    Ng√†y nay, AI ƒë√£ tr·ªü th√†nh m·ªôt c√¥ng c·ª• kh√¥ng th·ªÉ thi·∫øu trong c√¥ng vi·ªác h·∫±ng ng√†y, ƒë·∫∑c bi·ªát l√† ƒë·ªëi v·ªõi d√¢n vƒÉn ph√≤ng v√† l·∫≠p tr√¨nh vi√™n. Tuy nhi√™n, c√°c m√¥ h√¨nh AI hi·ªán t·∫°i v·∫´n g·∫∑p nhi·ªÅu h·∫°n ch·∫ø trong vi·ªác truy c·∫≠p v√† x·ª≠ l√Ω th√¥ng tin.

    V√¨ v·∫≠y, trong b√†i vi·∫øt n√†y, m√¨nh s·∫Ω gi·ªõi thi·ªáu m·ªôt ph∆∞∆°ng ph√°p gi√∫p n√¢ng cao kh·∫£ nƒÉng t√¨m ki·∫øm th√¥ng tin c·ªßa AI c≈©ng nh∆∞ c·∫£i thi·ªán c√°ch AI truy xu·∫•t d·ªØ li·ªáu m·ªôt c√°ch hi·ªáu qu·∫£ h∆°n.
---

## AI v√† con ng∆∞·ªùi: S·ª± t∆∞∆°ng ƒë·ªìng trong t√¨m ki·∫øm v√† x·ª≠ l√Ω th√¥ng tin

AI v√† con ng∆∞·ªùi ƒë·ªÅu c√≥ nh·ªØng ƒë·∫∑c ƒëi·ªÉm chung, ƒë·∫∑c bi·ªát trong vi·ªác t√¨m ki·∫øm v√† x·ª≠ l√Ω th√¥ng tin. V√¨ v·∫≠y, c·∫£ ch√∫ng ta v√† AI ƒë·ªÅu ph·∫£i ƒë·ªëi m·∫∑t v·ªõi nh·ªØng th√°ch th·ª©c t∆∞∆°ng t·ª± trong qu√° tr√¨nh n√†y. ƒê·ªÉ hi·ªÉu r√µ h∆°n, h√£y b·∫Øt ƒë·∫ßu t·ª´ ch√≠nh con ng∆∞·ªùi ‚Äì c√°ch ch√∫ng ta t√¨m ki·∫øm v√† x·ª≠ l√Ω th√¥ng tin.

Gi·∫£ s·ª≠ b·∫°n l√† m·ªôt ng∆∞·ªùi th√¥ng minh, c√≥ kh·∫£ nƒÉng ph√¢n t√≠ch v√† x·ª≠ l√Ω th√¥ng tin t·ªët. Tuy nhi√™n, b·∫°n kh√¥ng th·ªÉ bi·∫øt m·ªçi th·ª©. Khi g·∫∑p m·ªôt kh√°i ni·ªám m·ªõi, ch·∫≥ng h·∫°n nh∆∞ ‚ÄúRAG‚Äù, b·ªô n√£o c·ªßa b·∫°n s·∫Ω v·∫≠n h√†nh theo quy tr√¨nh sau:

1.	Ki·ªÉm tra ki·∫øn th·ª©c hi·ªán c√≥: B·∫°n ƒë√£ bi·∫øt v·ªÅ RAG ch∆∞a? N·∫øu ch∆∞a, b∆∞·ªõc ti·∫øp theo l√† t√¨m ki·∫øm th√¥ng tin.
2.	T√¨m ki·∫øm th√¥ng tin: B·∫°n l√™n Google v√† nh·∫≠p t·ª´ kh√≥a ‚ÄúRAG‚Äù.
3.	L·ªçc v√† ƒë·ªçc th√¥ng tin: B·∫°n xem x√©t c√°c k·∫øt qu·∫£ tr·∫£ v·ªÅ, ch·ªçn ra nh·ªØng ngu·ªìn ph√π h·ª£p nh·∫•t v√† ƒë·ªçc ch√∫ng.
4.	Ph√¢n t√≠ch v√† t·ªïng h·ª£p: B·∫°n x·ª≠ l√Ω th√¥ng tin v·ª´a thu th·∫≠p ƒë·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ RAG.
5.	ƒê∆∞a ra c√¢u tr·∫£ l·ªùi: D·ª±a tr√™n th√¥ng tin ƒë√£ ph√¢n t√≠ch, b·∫°n tr·∫£ l·ªùi c√¢u h·ªèi.

Quy tr√¨nh n√†y c≈©ng √°p d·ª•ng cho AI. M·∫∑c d√π AI kh√¥ng th·ªÉ ‚Äúbi·∫øt‚Äù m·ªçi th·ª©, nh∆∞ng n√≥ c√≥ kh·∫£ nƒÉng t√¨m ki·∫øm, ph√¢n t√≠ch v√† t·ªïng h·ª£p th√¥ng tin m·ªôt c√°ch hi·ªáu qu·∫£ d·ª±a tr√™n d·ªØ li·ªáu ƒë·∫ßu v√†o.

## Hi·ªÉu ƒë∆°n gi·∫£n v·ªÅ RAG

RAG (Retrieval-Augmented Generation) l√† m·ªôt ph∆∞∆°ng ph√°p gi√∫p AI t√¨m ki·∫øm v√† s·ª≠ d·ª•ng th√¥ng tin m·ªôt c√°ch hi·ªáu qu·∫£ h∆°n.

M·ªôt h·ªá th·ªëng RAG ƒëi·ªÉn h√¨nh bao g·ªìm hai th√†nh ph·∫ßn ch√≠nh:
	‚Ä¢	B·ªô t√¨m ki·∫øm th√¥ng tin: T√¨m ki·∫øm trong kho d·ªØ li·ªáu l·ªõn v√† tr·∫£ v·ªÅ nh·ªØng k·∫øt qu·∫£ li√™n quan nh·∫•t ƒë·∫øn truy v·∫•n.
	‚Ä¢	B·ªô x·ª≠ l√Ω th√¥ng tin: Ph√¢n t√≠ch d·ªØ li·ªáu t√¨m ƒë∆∞·ª£c c√πng v·ªõi truy v·∫•n ƒë·ªÉ ƒë∆∞a ra c√¢u tr·∫£ l·ªùi ch√≠nh x√°c.

Nh·ªù RAG, AI c√≥ th·ªÉ khai th√°c th√¥ng tin t·ª´ ngu·ªìn d·ªØ li·ªáu b√™n ngo√†i thay v√¨ ch·ªâ d·ª±a v√†o ki·∫øn th·ª©c c√≥ s·∫µn, gi√∫p n√¢ng cao ƒë·ªô ch√≠nh x√°c v√† t√≠nh c·∫≠p nh·∫≠t c·ªßa c√¢u tr·∫£ l·ªùi.


## Chu·∫©n b·ªã

Trong b√†i vi·∫øt n√†y, m√¨nh s·∫Ω s·ª≠ d·ª•ng RediSearch l√†m b·ªô t√¨m ki·∫øm th√¥ng tin v√† m√¥ h√¨nh Llama 3.1 th√¥ng qua Ollama.

D∆∞·ªõi ƒë√¢y l√† th√¥ng tin v√† h∆∞·ªõng d·∫´n c√†i ƒë·∫∑t:

- RediSearch [https://redis.io/docs/latest/develop/interact/search-and-query/](https://redis.io/docs/latest/develop/interact/search-and-query/)
- Ollama [https://ollama.com](https://ollama.com)

## X√¢y d·ª±ng b·ªô t√¨m ki·∫øm th√¥ng tin

### 1. Ingest d·ªØ li·ªáu

Trong b√†i vi·∫øt n√†y, b·ªô d·ªØ li·ªáu ƒë·∫ßu v√†o l√† to√†n b·ªô email c·ªßa m√¨nh, ƒë∆∞·ª£c ƒë·∫©y v√†o RediSearch ƒë·ªÉ ph·ª•c v·ª• t√¨m ki·∫øm.

M·ªói email sau khi t·∫£i v·ªÅ t·ª´ Gmail s·∫Ω ƒë∆∞·ª£c vector h√≥a b·∫±ng thu·∫≠t to√°n embedding. M√¨nh s·∫Ω ƒëi s√¢u h∆°n v√†o qu√° tr√¨nh n√†y trong c√°c b√†i vi·∫øt sau.

Hi·ªán t·∫°i, b·∫°n ch·ªâ c·∫ßn hi·ªÉu r·∫±ng d·ªØ li·ªáu ƒë·∫ßu v√†o ban ƒë·∫ßu c√≥ ƒë·ªô d√†i bi·∫øn ƒë·ªïi (variable length), nh∆∞ng c·∫ßn ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi th√†nh d·∫°ng c√≥ ƒë·ªô d√†i c·ªë ƒë·ªãnh (fixed length). C·ª• th·ªÉ, m√¨nh s·ª≠ d·ª•ng vector c√≥ 384 chi·ªÅu ƒë·ªÉ bi·ªÉu di·ªÖn m·ªói email.

Sau khi d·ªØ li·ªáu ƒë∆∞·ª£c vector h√≥a, thu·∫≠t to√°n KNN (K-Nearest Neighbors) s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t√¨m ki·∫øm nh·ªØng email c√≥ n·ªôi dung li√™n quan nh·∫•t, gi√∫p AI m√¥ h√¨nh truy xu·∫•t th√¥ng tin hi·ªáu qu·∫£.

C√¥ng c·ª• v√† th∆∞ vi·ªán s·ª≠ d·ª•ng

M√¨nh s·ª≠ d·ª•ng Python c√πng v·ªõi c√°c th∆∞ vi·ªán sau:

```
google-api-python-client==2.122.0
google-auth-httplib2==0.2.0
google-auth-oauthlib==1.2.0
redis>=5.2.1
sentence-transformers>=4.0.1
```

ƒêo·∫°n code d∆∞·ªõi ƒë·ªÉ l·∫•y crendentials t·ª´ google. File credentials.json l√† m·ªôt service account key c√°c b·∫°n c√≥ th·ªÉ t·∫°o tr√™n Console c·ªßa Google Cloud Platform.

```python
import os.path
import pickle
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build


def get_gmail_service():
    """Gets Gmail API service instance."""
    creds = None
    pickle_file = os.path.join(ROOT_DIR, 'etc', 'token.pickle')

    # The file token.pickle stores the user's access and refresh tokens
    if os.path.exists(pickle_file):
        with open(pickle_file, 'rb') as token:
            creds = pickle.load(token)
    
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())

        else:

            flow = InstalledAppFlow.from_client_secrets_file(
                os.path.join(ROOT_DIR, 'etc', 'credentials.json'), SCOPES)

            # Default port that matches Google Cloud Console's default redirect URI
            creds = flow.run_local_server(port=8000)

        # Save the credentials for the next run
        with open(pickle_file, 'wb') as token:
            pickle.dump(creds, token)

    return build('gmail', 'v1', credentials=creds)
```

Function n√†y s·∫Ω l·∫•y danh s√°ch email t·ª´ start_date ƒë·∫øn end_date b·∫±ng Gmail query

```python
def get_list_emails(service, start_date=None, end_date=None):
    # Construct date query if dates provided
    query = ""
    if start_date:
        query += f"after:{start_date} "
    if end_date:
        query += f"before:{end_date}"
        
    # Get all message IDs first
    print("Fetching email IDs...")
    results = service.users().messages().list(userId='me', q=query).execute()
    messages = results.get('messages', [])
    
    # Keep getting messages if there are more pages
    while 'nextPageToken' in results:
        results = service.users().messages().list(
            userId='me',
            q=query,
            pageToken=results['nextPageToken']
        ).execute()
        messages.extend(results.get('messages', []))
        
    total_emails = len(messages)
    print(f"Found {total_emails} emails")

    return messages
```


```python
def get_detail_email(service, msg_id):
    message = service.users().messages().get(userId='me', id=msg_id, format='full').execute()

    body = ""
    try:
        if 'parts' in message['payload']:
            for part in message['payload']['parts']:
                if part['mimeType'] == 'text/plain':  # Can also check for 'text/html'
                    body = base64.urlsafe_b64decode(part['body']['data']).decode('utf-8')
                    break
        else:
            body = base64.urlsafe_b64decode(message['payload']['body']['data']).decode('utf-8')
    except Exception:
        body = ""

    # Extract headers
    headers = message['payload']['headers']
    email_data = {
        'id': msg_id,
        'subject': '',
        'from': '',
        'date': '',
        'snippet': message['snippet'],
        'body': body,
    }

    # Get relevant headers
    for header in headers:
        name = header['name'].lower()
        if name == 'subject':
            email_data['subject'] = header['value']
        elif name == 'from':
            email_data['from'] = header['value']
        elif name == 'date':
            email_data['date'] = header['value']
            
    return email_data
```

T·ª´ nh·ªØng function tr√™n, ch√∫ng ta c√≥ th·ªÉ l·∫•y emails nh∆∞ sau. Generator s·∫Ω l·∫•y tu·∫ßn t·ª± t·ª´ng email

```python
g_service = get_gmail_service()
list_emails = get_list_emails(g_service, '2024/01/01', '2024/12/31')
emails_generator = (get_detail_email(g_service, email['id']) for email in list_emails)
```

```python
def get_redis(db=0):
    return redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=db, decode_responses=True)
```

Ch√∫ng ta s·ª≠ d·ª•ng m√¥ h√¨nh __all-MiniLM-L6-v2__, m·ªôt m√¥ h√¨nh ƒë∆°n gi·∫£n nh∆∞ng c√≥ hi·ªáu nƒÉng cao. V√¨ n·ªôi dung email th∆∞·ªùng kh√¥ng qu√° d√†i hay ph·ª©c t·∫°p, n√™n m√¥ h√¨nh n√†y l√† l·ª±a ch·ªçn ph√π h·ª£p. N√≥ s·∫Ω chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n th√†nh embedding vector c√≥ 384 chi·ªÅu.

Ngo√†i ra, b·∫°n c≈©ng c√≥ th·ªÉ s·ª≠ d·ª•ng AI model t·ª´ Ollama ƒë·ªÉ th·ª±c hi·ªán vector h√≥a m√† kh√¥ng c·∫ßn import th√™m th∆∞ vi·ªán b√™n ngo√†i.

```python
def embed_text(text):
    model = SentenceTransformer('all-MiniLM-L6-v2')
    return model.encode(text).astype(np.float32).tobytes()
```

Ch√∫ng ta l∆∞u tr·ªØ email trong Redis d∆∞·ªõi d·∫°ng hashmap, bao g·ªìm c√°c th√¥ng tin l·∫•y t·ª´ Gmail v√† m·ªôt tr∆∞·ªùng b·ªï sung ch·ª©a embedding c·ªßa email.

```python
def store_in_redis(redis_client, email, embedding_vector):
    email_data = {
        "id": email['id'],
        "subject": email['subject'],
        "sender": email['from'],
        "date": email['date'],
        "snippet": email['snippet'],
        "body": email['body']
    }
    
    redis_client.hset(f"{REDIS_EMAIL_PREFIX_KEY}{email['id']}", mapping={
        **email,
        "embedding": embedding_vector
    }) 
```


B√¢y gi·ªù, ch√∫ng ta s·∫Ω thi·∫øt l·∫≠p pipeline ƒë·ªÉ ingest d·ªØ li·ªáu.
__embedding_vector__ ch√≠nh l√† vector bi·ªÉu di·ªÖn m√† m√¨nh ƒë√£ ƒë·ªÅ c·∫≠p tr∆∞·ªõc ƒë√≥. N√≥ ƒë∆∞·ª£c t·∫°o t·ª´ c√°c th√¥ng tin quan tr·ªçng c·ªßa email, bao g·ªìm __sender__ (ng∆∞·ªùi g·ª≠i), __subject__ (ti√™u ƒë·ªÅ) v√† __snippet__ (ƒëo·∫°n tr√≠ch n·ªôi dung).

```python
g_service = get_gmail_service()
redis_client = get_redis()

list_emails = get_list_emails(g_service, '2024/01/01', '2024/12/31')
emails_generator = (get_detail_email(g_service, email['id']) for email in list_emails)

for email in emails_generate:
    embed_text = f'sender:{email_data["sender"]} subject:{email_data["subject"]} snippet:{email_data["snippet"]}'
    embedding_vector = embed_text(embed_text)

    store_in_redis(redis_client, email, embedding_vector)
```

Sau khi ingest d·ªØ li·ªáu th√†nh c√¥ng, b∆∞·ªõc ti·∫øp theo l√† ƒë√°nh index ƒë·ªÉ t·ªëi ∆∞u hi·ªáu su·∫•t t√¨m ki·∫øm trong Redis.

Trong c·∫•u h√¨nh, m√¨nh thi·∫øt l·∫≠p tr∆∞·ªùng embedding d∆∞·ªõi d·∫°ng vector 384 chi·ªÅu v√† s·ª≠ d·ª•ng kho·∫£ng c√°ch cosine ƒë·ªÉ so s√°nh ƒë·ªô t∆∞∆°ng ƒë·ªìng gi·ªØa c√°c vector. B·∫°n c√≥ th·ªÉ t√¨m hi·ªÉu th√™m v·ªÅ cosine similarity t·∫°i ƒë√¢y:

[https://en.wikipedia.org/wiki/Cosine_similarity](https://en.wikipedia.org/wiki/Cosine_similarity)


```python
from redis.commands.search.field import TextField, VectorField
from redis.commands.search.indexDefinition import IndexDefinition, IndexType

def create_index_emails():
    r = utils.get_redis(0)
    vector_dim = 384

    # drop old index
    try:
        r.ft('email_idx').dropindex(delete_documents=False)
    except Exception:
        pass

    schema = (
        TextField("id"),
        TextField("subject"),
        TextField("sender"), 
        TextField("date"),
        TextField("snippet"),
        VectorField("embedding", 
                "FLAT", {
                    "TYPE": "FLOAT32",
                    "DIM": 384,
                    "DISTANCE_METRIC": "COSINE"
                })
    )

    definition = IndexDefinition(
        prefix=['emails:'],
        index_type=IndexType.HASH,
    )

    r.ft(REDIS_EMAIL_INDEX).create_index(schema, definition=definition)
```

## T√≠ch h·ª£p v·ªõi AI model

Ch√∫ng ta s·∫Ω vi·∫øt m·ªôt h√†m gi√∫p m√¥ h√¨nh AI __truy v·∫•n d·ªØ li·ªáu__ trong RediSearch. H√†m n√†y s·∫Ω t√¨m v√† tr·∫£ v·ªÅ __k email ph√π h·ª£p nh·∫•t__ v·ªõi truy v·∫•n ƒë·∫ßu v√†o.

```python
def search_redis(query, k=5):
    r = get_redis(0)
    query_embedding = embed_text(query)

    q = (
        Query("*=>[KNN $K @embedding $BLOB AS score]")
        .return_fields("id", "subject", "sender", "date", "snippet", "body", "score")
        .dialect(2)
    )
    
    query_params = {
        "K": k,
        "BLOB": query_embedding,
    }

    results = r.ft(REDIS_EMAIL_INDEX).search(q, query_params)
    
    if not results.docs:
        return []
    
    # Format results
    emails = []
    for doc in results.docs:
        email_data = {
            'id': doc.id.replace(REDIS_EMAIL_PREFIX_KEY, ''),
            'subject': doc.subject,
            'sender': doc.sender,
            'date': doc.date,
            'snippet': doc.snippet,
            'body': doc.body,
            'score': doc.score
        }
        emails.append(email_data)
        
    return emails
```


Ch√∫ng ta s·∫Ω s·ª≠ d·ª•ng m√¥ h√¨nh AI th√¥ng qua [Ollama SDK cho Python](https://github.com/ollama/ollama-python).

Khi nh·∫≠n ƒë∆∞·ª£c truy v·∫•n, b∆∞·ªõc ƒë·∫ßu ti√™n l√† h·ªèi AI xem c√≥ c·∫ßn t√¨m ki·∫øm th√¥ng tin trong database tr∆∞·ªõc hay kh√¥ng.
	‚Ä¢	N·∫øu c·∫ßn, h·ªá th·ªëng s·∫Ω truy v·∫•n d·ªØ li·ªáu t·ª´ database v√† th√™m v√†o context ƒë·ªÉ AI ph√¢n t√≠ch, t·ª´ ƒë√≥ ƒë∆∞a ra k·∫øt qu·∫£ ch√≠nh x√°c h∆°n.
	‚Ä¢	N·∫øu kh√¥ng, truy v·∫•n s·∫Ω ƒë∆∞·ª£c g·ª≠i tr·ª±c ti·∫øp ƒë·∫øn m√¥ h√¨nh AI ƒë·ªÉ x·ª≠ l√Ω ngay.

```python
try:
    query = input("Me: ")

    rich_query = f'''
    This is my query: {query}
    You can use function search_redis to search emails in redis database performantly.
    Do you want to use this function?
    Must responds only with yes or no.
    '''

    response = generate(
        model="llama3.1:8b",
        prompt=rich_query,
    )

    print('BOT: Hmm, Should I search the database? ', response.response)

    if response.response == "yes":
        results = search_redis(query, 2)
        context = '\n\n'.join([
            f'''
            Subject: {email['subject']}
            Snippet: {email['snippet']}
            From: {email['sender']}
            Date: {email['date']}
            '''
            for email in results
        ])

        query_with_context = f'''
        This is my query: {query}
        This is the context: {context} 
        Please use the results base on context
        '''

        print('AI: ', end='')
        for chunk in generate(
            model="llama3.1:8b",
            prompt=query_with_context,
            stream=True
        ):
            print(chunk.response, end='', flush=True)
        print('')

    else:
        print('AI: ', end='')
        for chunk in generate(
            model="llama3.1:8b",
            prompt=query,
            stream=True
        ):
            if 'response' in chunk:
                print(chunk['response'], end='', flush=True)
        print('')
        
except KeyboardInterrupt:
    exit(0)
```

<div style={{ witdth: '100%', display: 'flex', justifyContent: 'center' }}><iframe width="560" height="315" style={{maxWidth: "100%"}} src="https://www.youtube.com/embed/KSenNT42C-Q?si=PwOjFPo6Q7TWNtuX" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe></div>

## What's next?

C√°ch t√≠ch h·ª£p AI v·ªõi vector search nh∆∞ tr√™n tuy ƒë∆°n gi·∫£n nh∆∞ng ch∆∞a th·ª±c s·ª± hi·ªáu qu·∫£ v√† kh√≥ m·ªü r·ªông. V√¨ v·∫≠y, trong b√†i vi·∫øt ti·∫øp theo, m√¨nh s·∫Ω gi·ªõi thi·ªáu m·ªôt ph∆∞∆°ng ph√°p t√≠ch h·ª£p chu·∫©n h√≥a, ƒëang d·∫ßn tr·ªü th√†nh ti√™u chu·∫©n trong c·ªông ƒë·ªìng AI: Model Context Protocol (MCP).

MCP hi·ªán ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng trong m·ªôt s·ªë s·∫£n ph·∫©m AI nh∆∞ Claude Desktop v√† Cursor AI Editor. H√£y c√πng kh√°m ph√° ph∆∞∆°ng ph√°p n√†y trong b√†i vi·∫øt ti·∫øp theo!

H·∫πn g·∫∑p l·∫°i! üöÄ

## ƒê·ªçc th√™m

N·∫øu c√°c b·∫°n c√≥ h·ª©ng th√∫ v·ªõi vi·ªác c√†i ƒë·∫∑t m·ªôt h·ªá th·ªëng RAG thu·∫ßn tu√Ω b·∫±ng code Python m√† kh√¥ng s·ª≠ d·ª•ng RediSearch, b·∫°n c√≥ th·ªÉ tham kh·∫£o ·ªü ƒë√¢y [llama2 demo](https://github.com/magiskboy/llma2-demo)